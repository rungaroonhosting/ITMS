<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
// ✅ CRITICAL FIX: Add authentication interfaces and traits
use Illuminate\Contracts\Auth\Authenticatable;
use Illuminate\Auth\Authenticatable as AuthenticatableTrait;
use Illuminate\Contracts\Auth\Access\Authorizable;
use Illuminate\Foundation\Auth\Access\Authorizable as AuthorizableTrait;

class Employee extends Model implements Authenticatable, Authorizable
{
    use HasFactory, SoftDeletes, AuthenticatableTrait, AuthorizableTrait;

    protected $fillable = [
        'employee_code',
        'keycard_id',
        'first_name_th',
        'last_name_th',
        'first_name_en',
        'last_name_en',
        'nickname',
        'email',
        'login_email',
        'phone',
        'username',
        'password',
        'computer_password',
        'email_password',
        'copier_code',
        'express_username',
        'express_password',
        'department_id',
        'branch_id', // ✅ Branch support
        'position',
        'role',
        'status',
        'hire_date',
        'vpn_access',
        'color_printing',
        'remote_work',
        'admin_access',
        'photo', // ✅ Photo field
        'remember_token', // ✅ CRITICAL: Add remember_token for authentication
        'email_verified_at', // ✅ For email verification
    ];

    protected $hidden = [
        'password',
        'computer_password',
        'email_password',
        'express_password',
        'remember_token',
    ];

    protected $casts = [
        'hire_date' => 'date',
        'vpn_access' => 'boolean',
        'color_printing' => 'boolean',
        'remote_work' => 'boolean',
        'admin_access' => 'boolean',
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
    ];

    // =====================================================
    // ✅ AUTHENTICATION INTERFACE METHODS
    // =====================================================

    /**
     * Get the name of the unique identifier for the user.
     */
    public function getAuthIdentifierName()
    {
        return $this->getKeyName();
    }

    /**
     * Get the unique identifier for the user.
     */
    public function getAuthIdentifier()
    {
        return $this->getKey();
    }

    /**
     * Get the password for the user.
     */
    public function getAuthPassword()
    {
        return $this->password;
    }

    /**
     * Get the "remember me" token value.
     */
    public function getRememberToken()
    {
        return $this->remember_token;
    }

    /**
     * Set the "remember me" token value.
     */
    public function setRememberToken($value)
    {
        $this->remember_token = $value;
    }

    /**
     * Get the column name for the "remember me" token.
     */
    public function getRememberTokenName()
    {
        return 'remember_token';
    }

    // =====================================================
    // RELATIONSHIPS
    // =====================================================

    public function department()
    {
        return $this->belongsTo(Department::class);
    }

    public function branch()
    {
        return $this->belongsTo(Branch::class);
    }

    // =====================================================
    // ✅ ENHANCED PHOTO SYSTEM (FIXED)
    // =====================================================

    /**
     * ✅ FIXED: Get photo URL with proper storage handling
     */
    public function getPhotoUrlAttribute()
    {
        if (!$this->photo) {
            return $this->getDefaultPhotoUrl();
        }

        // ✅ CRITICAL FIX: Ensure storage link exists and file exists
        $photoPath = $this->photo;
        
        // Check if file exists in storage
        if (!Storage::disk('public')->exists($photoPath)) {
            Log::warning("Photo file not found: {$photoPath} for employee: {$this->id}");
            return $this->getDefaultPhotoUrl();
        }

        // Return URL with proper storage URL
        return Storage::disk('public')->url($photoPath);
    }

    /**
     * ✅ FIXED: Get default photo URL - Enhanced with better initials
     */
    public function getDefaultPhotoUrl()
    {
        // Get initials with fallbacks
        $initials = $this->getInitials();
        $color = $this->getAvatarColor();

        // Return a data URL for default avatar
        return "data:image/svg+xml;base64," . base64_encode(
            '<svg width="180" height="180" xmlns="http://www.w3.org/2000/svg">
                <rect width="180" height="180" fill="#' . $color . '"/>
                <text x="90" y="90" font-family="Arial, sans-serif" font-size="72" font-weight="bold" fill="white" text-anchor="middle" dominant-baseline="central">' . $initials . '</text>
            </svg>'
        );
    }

    /**
     * ✅ NEW: Get initials for avatar
     */
    public function getInitialsAttribute()
    {
        return $this->getInitials();
    }

    /**
     * ✅ NEW: Get avatar color
     */
    public function getAvatarColorAttribute()
    {
        return $this->getAvatarColor();
    }

    /**
     * ✅ PRIVATE: Generate initials
     */
    private function getInitials()
    {
        // Try English names first
        if ($this->first_name_en && $this->last_name_en) {
            return strtoupper(
                substr($this->first_name_en, 0, 1) . 
                substr($this->last_name_en, 0, 1)
            );
        }

        // Try Thai names
        if ($this->first_name_th && $this->last_name_th) {
            return strtoupper(
                mb_substr($this->first_name_th, 0, 1) . 
                mb_substr($this->last_name_th, 0, 1)
            );
        }

        // Try single name
        if ($this->first_name_en) {
            return strtoupper(substr($this->first_name_en, 0, 2));
        }

        if ($this->first_name_th) {
            return strtoupper(mb_substr($this->first_name_th, 0, 2));
        }

        // Use employee code as fallback
        if ($this->employee_code) {
            return strtoupper(substr($this->employee_code, -2));
        }

        // Ultimate fallback
        return 'EMP';
    }

    /**
     * ✅ PRIVATE: Generate avatar color based on name
     */
    private function getAvatarColor()
    {
        $colors = [
            'e74c3c', // Red
            '3498db', // Blue  
            '2ecc71', // Green
            'f39c12', // Orange
            '9b59b6', // Purple
            '1abc9c', // Turquoise
            'e67e22', // Orange (darker)
            '34495e', // Dark blue-gray
            'e91e63', // Pink
            '00bcd4', // Cyan
        ];

        $name = $this->first_name_en ?: $this->first_name_th ?: $this->employee_code ?: 'default';
        $index = crc32($name) % count($colors);
        return $colors[abs($index)];
    }

    /**
     * ✅ FIXED: Check if employee has photo
     */
    public function getHasPhotoAttribute()
    {
        return !empty($this->photo) && Storage::disk('public')->exists($this->photo);
    }

    /**
     * ✅ ENHANCED: Upload photo with better error handling
     */
    public function uploadPhoto($file)
    {
        try {
            if (!$file || !$file->isValid()) {
                throw new \Exception('Invalid file provided');
            }

            // Validate file
            $this->validatePhotoFile($file);

            // ✅ CRITICAL: Ensure directories exist
            $this->ensurePhotoDirectoryExists();

            // Generate unique filename
            $filename = $this->generatePhotoFilename($file);
            $directory = 'employees/photos';
            $path = $directory . '/' . $filename;

            // Delete old photo before uploading new one
            $this->deletePhotoFile();

            // Store the file
            $storedPath = $file->storeAs($directory, $filename, 'public');
            
            if (!$storedPath) {
                throw new \Exception('Failed to store photo file');
            }

            // Update database
            $this->update(['photo' => $storedPath]);

            Log::info("Photo uploaded successfully for employee {$this->id}: {$storedPath}");
            
            return $storedPath;

        } catch (\Exception $e) {
            Log::error("Photo upload failed for employee {$this->id}: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * ✅ ENHANCED: Delete photo with better cleanup
     */
    public function deletePhoto()
    {
        try {
            if (!$this->photo) {
                return true;
            }

            $photoPath = $this->photo;
            
            // Delete file from storage
            if (Storage::disk('public')->exists($photoPath)) {
                Storage::disk('public')->delete($photoPath);
            }

            // Update database
            $this->update(['photo' => null]);

            Log::info("Photo deleted successfully for employee {$this->id}: {$photoPath}");
            
            return true;

        } catch (\Exception $e) {
            Log::error("Photo deletion failed for employee {$this->id}: " . $e->getMessage());
            return false;
        }
    }

    /**
     * ✅ CRITICAL FIX: Get complete photo information with proper dimensions handling
     */
    public function getPhotoInfo()
    {
        $info = [
            'has_photo' => $this->has_photo,
            'photo_url' => $this->photo_url,
            'default_photo_url' => $this->getDefaultPhotoUrl(),
            'photo_path' => $this->photo,
            'file_size' => 0,
            'file_size_human' => '0 B',
            'last_modified' => null,
            'width' => null,
            'height' => null,
            'mime_type' => null,
            'dimensions' => null, // ✅ CRITICAL FIX: Always include dimensions key
        ];

        if ($this->has_photo && Storage::disk('public')->exists($this->photo)) {
            try {
                $filePath = Storage::disk('public')->path($this->photo);
                
                // File size
                if (file_exists($filePath)) {
                    $info['file_size'] = filesize($filePath);
                    $info['file_size_human'] = $this->formatBytes($info['file_size']);
                    $info['last_modified'] = date('d/m/Y H:i:s', filemtime($filePath));
                }
                
                // Get image dimensions
                $imageInfo = @getimagesize($filePath);
                if ($imageInfo !== false) {
                    $info['width'] = $imageInfo[0];
                    $info['height'] = $imageInfo[1];
                    $info['mime_type'] = $imageInfo['mime'];
                    
                    // ✅ CRITICAL FIX: Properly set dimensions array
                    $info['dimensions'] = [
                        'width' => $imageInfo[0],
                        'height' => $imageInfo[1]
                    ];
                }
            } catch (\Exception $e) {
                Log::warning("Failed to get photo info for employee {$this->id}: " . $e->getMessage());
                // Keep default values if error occurs
            }
        }

        return $info;
    }

    /**
     * ✅ PRIVATE: Validate photo file
     */
    private function validatePhotoFile($file)
    {
        $maxSize = 2 * 1024 * 1024; // 2MB
        $allowedMimes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];
        $allowedExtensions = ['jpg', 'jpeg', 'png', 'gif'];

        // Check file size
        if ($file->getSize() > $maxSize) {
            throw new \Exception('File size exceeds 2MB limit');
        }

        // Check MIME type
        if (!in_array($file->getMimeType(), $allowedMimes)) {
            throw new \Exception('Invalid file type. Only JPEG, PNG, and GIF are allowed');
        }

        // Check extension
        $extension = strtolower($file->getClientOriginalExtension());
        if (!in_array($extension, $allowedExtensions)) {
            throw new \Exception('Invalid file extension');
        }

        // Verify it's actually an image
        $imageInfo = @getimagesize($file->getPathname());
        if ($imageInfo === false) {
            throw new \Exception('File is not a valid image');
        }

        // Check dimensions
        if ($imageInfo[0] < 50 || $imageInfo[1] < 50) {
            throw new \Exception('Image too small. Minimum size is 50x50 pixels');
        }

        if ($imageInfo[0] > 2000 || $imageInfo[1] > 2000) {
            throw new \Exception('Image too large. Maximum size is 2000x2000 pixels');
        }
    }

    /**
     * ✅ CRITICAL: Ensure photo directory exists
     */
    private function ensurePhotoDirectoryExists()
    {
        $directory = 'employees/photos';
        
        if (!Storage::disk('public')->exists($directory)) {
            Storage::disk('public')->makeDirectory($directory, 0755, true);
            Log::info("Created photo directory: {$directory}");
        }

        // Also ensure the symlink exists
        $publicPath = public_path('storage');
        $storagePath = storage_path('app/public');
        
        if (!file_exists($publicPath)) {
            if (function_exists('symlink')) {
                symlink($storagePath, $publicPath);
                Log::info("Created storage symlink: {$publicPath} -> {$storagePath}");
            } else {
                Log::warning("Cannot create symlink. Please run: php artisan storage:link");
            }
        }
    }

    /**
     * ✅ PRIVATE: Generate unique photo filename
     */
    private function generatePhotoFilename($file)
    {
        $extension = strtolower($file->getClientOriginalExtension());
        $employeeCode = preg_replace('/[^a-zA-Z0-9]/', '', $this->employee_code ?? 'TEMP');
        $timestamp = now()->format('YmdHis');
        $random = Str::random(6);
        
        return "{$employeeCode}_{$timestamp}_{$random}.{$extension}";
    }

    /**
     * ✅ PRIVATE: Delete photo file only
     */
    private function deletePhotoFile()
    {
        if ($this->photo && Storage::disk('public')->exists($this->photo)) {
            Storage::disk('public')->delete($this->photo);
            Log::info("Deleted old photo: {$this->photo}");
        }
    }

    /**
     * ✅ PRIVATE: Format bytes to human readable
     */
    private function formatBytes($bytes, $precision = 2)
    {
        if ($bytes === 0) return '0 B';
        
        $units = ['B', 'KB', 'MB', 'GB'];
        
        for ($i = 0; $bytes > 1024 && $i < count($units) - 1; $i++) {
            $bytes /= 1024;
        }
        
        return round($bytes, $precision) . ' ' . $units[$i];
    }

    // =====================================================
    // MODEL EVENTS
    // =====================================================

    protected static function boot()
    {
        parent::boot();

        // ✅ Auto-delete photo when employee is deleted
        static::deleting(function ($employee) {
            if ($employee->isForceDeleting()) {
                // Permanent delete - remove photo
                $employee->deletePhotoFile();
                Log::info("Photo deleted on force delete for employee: {$employee->id}");
            }
            // Soft delete - keep photo
        });

        // ✅ Create default values
        static::creating(function ($employee) {
            // Ensure storage directory exists when creating employee
            if (!Storage::disk('public')->exists('employees/photos')) {
                Storage::disk('public')->makeDirectory('employees/photos', 0755, true);
            }
        });
    }

    // =====================================================
    // ACCESSORS & MUTATORS
    // =====================================================

    public function getFullNameThAttribute()
    {
        return trim($this->first_name_th . ' ' . $this->last_name_th);
    }

    public function getFullNameEnAttribute()
    {
        return trim($this->first_name_en . ' ' . $this->last_name_en);
    }

    public function getRoleDisplayAttribute()
    {
        $roles = [
            'super_admin' => 'Super Admin',
            'it_admin' => 'IT Admin',
            'hr' => 'HR',
            'manager' => 'Manager',
            'express' => 'Express',
            'employee' => 'Employee',
        ];

        return $roles[$this->role] ?? $this->role;
    }

    public function getStatusDisplayAttribute()
    {
        return $this->status === 'active' ? 'ใช้งาน' : 'ไม่ใช้งาน';
    }

    // =====================================================
    // ✅ AUTHENTICATION HELPER: Get display name for login
    // =====================================================

    public function getNameAttribute()
    {
        return $this->full_name_th ?: $this->full_name_en ?: $this->email;
    }

    // =====================================================
    // SCOPES
    // =====================================================

    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    public function scopeWithPhoto($query)
    {
        return $query->whereNotNull('photo');
    }

    public function scopeWithoutPhoto($query)
    {
        return $query->whereNull('photo');
    }

    public function scopeByDepartment($query, $departmentId)
    {
        return $query->where('department_id', $departmentId);
    }

    public function scopeByBranch($query, $branchId)
    {
        return $query->where('branch_id', $branchId);
    }

    public function scopeByRole($query, $role)
    {
        return $query->where('role', $role);
    }

    public function scopeExpressUsers($query)
    {
        return $query->whereNotNull('express_username');
    }

    // =====================================================
    // HELPER METHODS
    // =====================================================

    public function hasRole($roles)
    {
        if (is_string($roles)) {
            return $this->role === $roles;
        }

        if (is_array($roles)) {
            return in_array($this->role, $roles);
        }

        return false;
    }

    public function canEdit($employee)
    {
        if ($this->role === 'super_admin') {
            return true;
        }

        if ($this->role === 'it_admin' && $employee->role !== 'super_admin') {
            return true;
        }

        if ($this->role === 'hr' && in_array($employee->role, ['employee', 'express'])) {
            return true;
        }

        return $this->id === $employee->id;
    }

    public function canAccess($employee)
    {
        if ($this->role === 'super_admin') {
            return true;
        }

        if ($this->role === 'it_admin' && $employee->role !== 'super_admin') {
            return true;
        }

        if ($this->role === 'hr' && in_array($employee->role, ['employee', 'express'])) {
            return true;
        }

        return $this->id === $employee->id;
    }

    /**
     * ✅ NEW: Get photo storage statistics
     */
    public static function getPhotoStatistics()
    {
        $stats = [
            'total_employees' => self::withoutTrashed()->count(),
            'with_photo' => self::withoutTrashed()->whereNotNull('photo')->count(),
            'without_photo' => self::withoutTrashed()->whereNull('photo')->count(),
            'storage_used' => 0,
            'average_file_size' => 0,
        ];

        // Calculate storage usage
        $employees = self::withoutTrashed()->whereNotNull('photo')->get();
        $totalSize = 0;
        $validPhotos = 0;

        foreach ($employees as $employee) {
            if (Storage::disk('public')->exists($employee->photo)) {
                $fileSize = Storage::disk('public')->size($employee->photo);
                $totalSize += $fileSize;
                $validPhotos++;
            }
        }

        $stats['storage_used'] = $totalSize;
        $stats['storage_used_mb'] = round($totalSize / 1024 / 1024, 2);
        $stats['average_file_size'] = $validPhotos > 0 ? round($totalSize / $validPhotos) : 0;
        $stats['valid_photos'] = $validPhotos;
        $stats['coverage_percentage'] = $stats['total_employees'] > 0 ? 
            round(($stats['with_photo'] / $stats['total_employees']) * 100, 1) : 0;

        return $stats;
    }
}
